#!/usr/bin/env ruby 
#== czsearch is a userful command to search via the Code Zauker facility
# Send something like -W0 to ruby, for a cleaner output
$VERBOSE=nil 
require 'code_zauker'
require 'code_zauker/grep'
require 'code_zauker/cli'
require 'redis/connection/hiredis'
require 'redis'
require 'tempfile'
require 'pdf/reader'
include Grep

require 'optparse'
options={}
optparse= OptionParser.new do  |opts|
  opts.banner="Usage: czsearch [options] [term1] [term2]..."
  options[:ignorecase]=false
  options[:precontext]=0
  options[:postcontext]=0
  options[:extensions_to_ignore]=[]
  options[:file_to_exclude]=[]
  options[:redis_host]="127.0.0.1"
  options[:redis_port]=6379
  options[:redis_password]=nil
  options[:be_wild]=false

  opts.on('-i', '--ignore-case','ignore case distinctions') do 
      options[:ignorecase]=true    
  end

  opts.on('-B', '--before-context NUM', Integer, 'print NUM lines of leading context') do | c |
    options[:precontext]=c
  end

  opts.on('-A','--after-context NUM',Integer,'print NUM lines of trailing context') do | c |
    options[:postcontext]=c
  end
  opts.on('-C','--context NUM',Integer,'print NUM lines of output context') do | c |
    if c>0 
      options[:postcontext]=c
      options[:precontext]=options[:postcontext]
    end
  end
  
  
  opts.on('-X','--exclude FILE_PATTERN',String,
          'Exclude files that match FILE_PATTERN (as ruby regexp). Case insensitive') do |p|
    options[:file_to_exclude].push(/#{Regexp.escape(p)}/i);
  end

  opts.on('-w','--wild','Do a wildcharacter search. * means "every char". Imply -i') do 
    options[:be_wild] = true
    options[:ignorecase]=true
  end


  opts.on('-h','--redis-server pass@SERVER:port', String,
          'Specify the alternate redis server to use')do |server|
    myoptions=CodeZauker::CliUtil.new().parse_host_options(server)
    options[:redis_host]=myoptions[:redis_host]
    options[:redis_port]=myoptions[:redis_port]
    options[:redis_password]=myoptions[:redis_password]
    
    if options[:redis_password]
      puts "Server: #{options[:redis_host]} Port:#{options[:redis_port]} WithPassword"
    else
      puts "Server: #{options[:redis_host]} Port:#{options[:redis_port]}"
    end
  end



  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts   
    puts "EXAMPLES:"
    puts "czsearch ciao Koros"
    puts " Will search Koros OR ciao"
    puts "czsearch -i gnu"
    puts " Will match also GNU and Gnu"   
    puts "czsearch  -X .orig -X .bak -X .java  html:select"
    puts " Will skip java and backup file"
    puts "czsearch -w 'public*class School'"
    puts " Will seach for a java class called School ignoring characters between public and class."
    exit
  end
end
optparse.parse!

ARGV.each do | s |
  #puts "Code Zauker Searching for #{s}"  
  util=CodeZauker::Util.new()
  redisConnection=Redis.new(:host => options[:redis_host], :port => options[:redis_port], :password=> options[:redis_password])
  fs=CodeZauker::FileScanner.new(redisConnection)

  if options[:be_wild]==true
    puts "Wild MODE"
    cli=CodeZauker::CliUtil.new()
    r=cli.doWildSearch(s,fs)
    files=  r[:files]
    pattern=r[:regexp]
  else
    # It uses always isearch
    # and delegates to the grep subsystem to find it out
    files=fs.isearch(s)
    if options[:ignorecase]==false      
      pattern=/#{Regexp.escape(s)}/
    else
      pattern=/#{Regexp.escape(s)}/i
    end
  end

  files.each do |f|
    to_exclude=false
    if options[:file_to_exclude].length >0
      # Will match?
      to_exclude=false
      options[:file_to_exclude].each do |pattern|
        #puts "\n\t#{f} =~  #{pattern}"
        if (f  =~ pattern )
          to_exclude=true
          #puts "Excluded #{f}"
          break
        end
      end
    end
    
    # Does it exist?
    if !to_exclude && !File.exists?(f)
      #puts "WARN: Not FOUND #{f}"
      to_exclude=true
    end

    if !to_exclude
      begin
        if util.is_pdf?(f)==false
          lines=grep(f,pattern, pre_context=options[:precontext], post_context=options[:postcontext]);
          lines.each do |l |
            puts "#{f}:#{l}"
          end
        else
          puts "#{f} Pdf matches"
          #Using pdf/reader we can do a search here but we must store the stuff 
          # in a temp file
          
          tempfile =Tempfile.new("czsearch_pdf.tmp")
          tempfile.write(util.get_lines(f).join("\n"))
          tempfile.close
          #puts "Temp PDF into #{tempfile.path}"
          lines=grep(tempfile.path,pattern, pre_context=options[:precontext], post_context=options[:postcontext]);
          lines.each do |l |
            puts "#{f}:#{l}"
          end
          tempfile.unlink
        end
      rescue ArgumentError => ioe
        puts "FATAL ArgumentError on #{f}"
        raise ioe
      end
    else
      
    end
  end
end
